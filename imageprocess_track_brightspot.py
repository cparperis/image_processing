#########################################################################     Change the 'file_name' variable to analyse different       ######     movie files.                                               ######                                                                ######     Change the feature-finding variables to check how well     ######     feature-finding is working. 'frame' will change the Z-     ######     slice on display from the movie being analysed. 'spot_     ######     intensity' changes the minimum combined pixel values       ######     accepted as a feature. 'feature_diameter' changes the      ######     spot size that will be searched for. ('feature_diameter'   ######     must be an odd integer.)                                   ######                                                                ######     Change the image crop variables to crop the image around   ######     the square laser profile in the movie.                     ############################################################################ File to analyse:file_name = '/Users/Christopher/Documents/Code/Python/RI Difference Experiments/20ag_20droplet--1--bkgcrctd.tif'### Feature finding variables:frame = 9spot_intensity = 4E4feature_diameter = 19######################################################################## Image crop variables:crop_x_minimum = 240crop_x_maximum = 880crop_y_minimum = 180crop_y_maximum = 830################################################################################################################################################################################################################## Main body of feature-finding code ###import numpy as npimport matplotlib.pyplot as pltimport matplotlib as mplimport trackpy as tpimport seaborn as snsfrom scipy import interpolatefrom pandas import DataFrame, Seriesfrom microImage import loadImage### Convert image file to an array numpy can useimageArray = loadImage(file_name)### Crop image to laser profilecropped_im40ag_40droplet_1 = imageArray[:,crop_y_minimum:crop_y_maximum,crop_x_minimum:crop_x_maximum]### Locate features in image. Invert set to True because### trackpy only recognises bright objects on dark background.feature_locations1 = tp.locate(cropped_im40ag_40droplet_1[frame], feature_diameter, minmass=spot_intensity, invert=False)###displaytp.annotate(feature_locations1, cropped_im40ag_40droplet_1[frame])plt.title('Located Features')plt.show#%%import pandas as pdall_feature_locations1 = tp.batch(cropped_im40ag_40droplet_1[:], feature_diameter, minmass=spot_intensity, invert=False)mean_pixel_value1 = np.mean(cropped_im40ag_40droplet_1)signal_to_contrast1 = all_feature_locations1.apply(lambda x: x/mean_pixel_value1*100 if x.name == 'signal' else x)print(signal_to_contrast1)#%%######################################################################### File to analyse:file_name = '/Users/Christopher/Documents/Code/Python/RI Difference Experiments/20ag_20droplet--2--bkgcrctd.tif'### Feature finding variables:frame = 0spot_intensity2 = 4E4feature_diameter = 19######################################################################## Image crop variables:crop_x_minimum = 240crop_x_maximum = 880crop_y_minimum = 180crop_y_maximum = 830################################################################################################################################################################################################################## Main body of feature-finding code ###import numpy as npimport matplotlib.pyplot as pltimport matplotlib as mplimport trackpy as tpimport seaborn as snsfrom scipy import interpolatefrom pandas import DataFrame, Seriesfrom microImage import loadImage### Convert image file to an array numpy can useimageArray = loadImage(file_name)### Crop image to laser profilecropped_im40ag_40droplet_2 = imageArray[:,crop_y_minimum:crop_y_maximum,crop_x_minimum:crop_x_maximum]### Locate features in image. Invert set to True because### trackpy only recognises bright objects on dark background.feature_locations2 = tp.locate(cropped_im40ag_40droplet_2[frame], feature_diameter, minmass=spot_intensity2, invert=False)###displaytp.annotate(feature_locations2, cropped_im40ag_40droplet_2[frame])plt.title('Located Features')plt.showimport pandas as pdall_feature_locations2 = tp.batch(cropped_im40ag_40droplet_2[:], feature_diameter, minmass=spot_intensity2, invert=False)mean_pixel_value2 = np.mean(cropped_im40ag_40droplet_2)signal_to_contrast2 = all_feature_locations2.apply(lambda x: x/mean_pixel_value2*100 if x.name == 'signal' else x)print(signal_to_contrast2)######################################################################### File to analyse:file_name = '/Users/Christopher/Documents/Code/Python/RI Difference Experiments/20ag_20droplet--3--bkgcrctd.tif'### Feature finding variables:frame = 0spot_intensity3 = 4E4feature_diameter = 19######################################################################## Image crop variables:crop_x_minimum = 240crop_x_maximum = 880crop_y_minimum = 180crop_y_maximum = 830################################################################################################################################################################################################################## Main body of feature-finding code ###import numpy as npimport matplotlib.pyplot as pltimport matplotlib as mplimport trackpy as tpimport seaborn as snsfrom scipy import interpolatefrom pandas import DataFrame, Seriesfrom microImage import loadImage### Convert image file to an array numpy can useimageArray = loadImage(file_name)### Crop image to laser profilecropped_im40ag_40droplet_3 = imageArray[:,crop_y_minimum:crop_y_maximum,crop_x_minimum:crop_x_maximum]### Locate features in image. Invert set to True because### trackpy only recognises bright objects on dark background.feature_locations3 = tp.locate(cropped_im40ag_40droplet_3[frame], feature_diameter, minmass=spot_intensity3, invert=False)###displaytp.annotate(feature_locations3, cropped_im40ag_40droplet_3[frame])plt.title('Located Features')plt.showimport pandas as pdall_feature_locations3 = tp.batch(cropped_im40ag_40droplet_3[:], feature_diameter, minmass=spot_intensity3, invert=False)mean_pixel_value3 = np.mean(cropped_im40ag_40droplet_3)signal_to_contrast3 = all_feature_locations3.apply(lambda x: x/mean_pixel_value3*100 if x.name == 'signal' else x)print(signal_to_contrast3)#%%appended = signal_to_contrast1.append(signal_to_contrast2)final = appended.append(signal_to_contrast3)print(final)print(final['signal'])#%%final.to_csv(r'/Users/Christopher/Documents/Code/Python/RI Difference Experiments/20ag_20droplet.csv', index=False)#%%#sns.distplot(final['signal'], color='skyblue', axlabel='Image Contrast (%)')#%%#print(all_feature_locations.head(None))#%%#mean_pixel_value = np.mean(cropped_im)#print(mean_pixel_value)#%%#signal_to_contrast['signal'].hist(bins=70)#import pandas as pd#signal_intensities = feature_locations['signal']#print(signal_intensities)#mean_pixel_value = np.mean(cropped_im)#def calculate_contrast(signal):#    return signal['signal'] / mean_pixel_value * 100#contrast = signal_intensities.apply(calculate_contrast)###display image [frame number 0-299]#plt.imshow(cropped_im[100], cmap='gray')#plt.show#%%#import pandas as pd#mean_pixel_value = np.mean(cropped_im)#signal_to_contrast = feature_locations.apply(lambda x: x/mean_pixel_value*100 if x.name == 'signal' else x)#%%#print(signal_to_contrast)#%%#mean_pixel_value = np.mean(cropped_im)#signal_to_contrast2 = feature_locations.apply(lambda x: x/mean_pixel_value*100 if x.name == 'signal' else x)#print(signal_to_contrast2)#%%#test = signal_to_contrast.append(signal_to_contrast2)#print(test)